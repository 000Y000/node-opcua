"use strict";

/**
 * @module opcua.address_space
 */
require("requirish")._(module);

var assert = require("better-assert");
var _ = require("underscore");
var UAVariable = require("lib/address_space/ua_variable").UAVariable;
var Variant = require("lib/datamodel/variant").Variant;
var DataType = require("lib/datamodel/variant").DataType;

var capitalizeFirstLetter = require("lib/misc/utils").capitalizeFirstLetter;
var lowerFirstLetter = require("lib/misc/utils").lowerFirstLetter;

exports.install = function (AddressSpace) {

    /**
     * add a new event type to the address space
     * @method addEventType
     * @param options
     * @param options.browseName {String} the eventType name
     * @param [options.subtypeOf ="BaseEventType"]
     * @return {UAObjectType} : the object type
     *
     * @example:
     *
     *    var evtType = addressSpace.addEventType({
     *      browseName: "MyAuditEventType",
     *      subtypeOf:  "AuditEventType"
     *    });
     *
     */
    AddressSpace.prototype.addEventType = function (options) {
        options.subtypeOf = options.subtypeOf || "BaseEventType";
        // are eventType always abstract ?? (todo check this assertion)
        options.isAbstract = options.hasOwnProperty("isAbstract") ? options.isAbstract : true;
        return this.addObjectType(options);
    };

    //function _coerceEventType(addressSpace, eventType) {
    //
    //    var nodeid = makeNodeId(ObjectTypeIds[eventType]);
    //    var eventTypeNode = addressSpace.findObject(nodeid);
    //    return eventTypeNode;
    //}
    /**
     * find an EventType node in the address space
     * @method findEventType
     * @param eventTypeId {String|NodeId} the eventType to find
     * @return {UAObjectType|null} the EventType found or null.
     *
     * note:
     *    - the method with throw an exception if a node is found
     *      that is not a BaseEventType or a subtype of it.
     *
     * @example
     *
     *     var evtType = addressSpace.findEventType("AuditEventType");
     *
     */
    AddressSpace.prototype.findEventType = function (eventTypeId) {

        var eventType;
        if (eventTypeId && eventTypeId.nodeId) {
            eventType = eventTypeId;
        } else {
            eventType = this.findObjectType(eventTypeId);
        }
        if (!eventType) {
            return null;
        }
        var baseEventType = this.findObjectType("BaseEventType");
        assert(baseEventType,"expecting BaseEventType - please check you nodeset xml file!");

        if (eventType.nodeId === baseEventType.nodeId) {
            return eventType;
        }
        /* eventTypeNode should be subtypeOf("BaseEventType"); */
        /* istanbul ignore next */
        if (!eventType.isSupertypeOf(baseEventType)) {
            throw new Error("findEventType: event found is not subType of BaseEventType");
        }
        return eventType;
        // return (eventType.isSupertypeOf(baseEventType) || eventType.nodeId === baseEventType.nodeId)? eventType : null;
    };

    /**
     * EventId is generated by the Server to uniquely identify a particular Event Notification.
     * @method generateEventId
     * @return {number|*|Variant}
     */
    AddressSpace.prototype.generateEventId = function () {
        /*
         * OpcUA 1.02 part 5 : 6.4.2 BaseEventType
         * The Server is responsible to ensure that each Event has its unique EventId.
         * It may do this, for example, by putting GUIDs into the ByteString.
         * Clients can use the EventId to assist in minimizing or eliminating gaps and overlaps that may occur during
         * a redundancy fail-over. The EventId shall always be returned as value and the Server is not allowed to
         * return a StatusCode for the EventId indicating an error.
         *
         */
        var self = this;
        var offset = 16;
        if(!self._eventIdCounter) {
             self._eventIdCounter = require("crypto").randomBytes(20);
             self._eventIdCounter.writeInt32BE(0,offset);
        }
        self._eventIdCounter.writeInt32BE(self._eventIdCounter.readInt32BE(offset)+1,offset);

        return new Variant({value: new Buffer(self._eventIdCounter), dataType: "ByteString"});
    };

    /*
     * construct a simple javascript object with all the default properties of the event
     * @method constructEventData
     *
     * @private
     */
    AddressSpace.prototype.constructEventData = function (eventTypeId, options) {

        var addressSpace = this;

        options = options || {};

        // construct the reference dataStructure to store event Data
        var eventTypeNode = addressSpace.findEventType(eventTypeId);
        /* istanbul ignore next */
        if (!eventTypeNode) {
            throw new Error(" cannot find EvenType for " + eventTypeId);
        }


        // eventId
        assert(options.hasOwnProperty,"eventId","constructEventData : options object should not have eventId property");
        options.eventId = addressSpace.generateEventId();

        // eventType
        options.eventType = { dataType: DataType.NodeId, value: eventTypeNode.nodeId};

        // sourceNode
        assert(options.hasOwnProperty("sourceNode"), "expecting a source node to be defined");
        options.sourceNode = new Variant(options.sourceNode);
        assert(options.sourceNode.dataType ===  DataType.NodeId);

        // sourceName
        var sourceNode = addressSpace.findObject(options.sourceNode.value);

        options.sourceName = options.sourceName || { dataType:  DataType.String, value: sourceNode.displayName.toString() };

        var nowUTC = (new Date());

        // time (UtcTime)
        // TODO
        options.time = options.time  ||  { dataType: DataType.DateTime, value: nowUTC};

        // receivedTime  (UtcTime)
        // TODO
        options.receiveTime = options.receiveTime  ||  { dataType: DataType.DateTime, value: nowUTC};

        // localTime  (UtcTime)
        // TODO
        options.localTime = options.localTime  ||  { dataType: DataType.DateTime, value: nowUTC};

        // message  (LocalizedText)
        options.message = options.message  ||  { dataType: DataType.LocalizedText, value: { text: "" } };

        // severity  (UInt16)
        options.severity = options.severity  ||  { dataType: DataType.UInt16, value: 0 };

        //xx // reminder : event type cannot be instantiated directly !
        //xx assert(eventTypeNode.isAbstract);

        var baseObjectType = addressSpace.findObjectType("BaseObjectType"); // i=58
        assert(baseObjectType, "Ba seObjectType must be defined in the address space");

        function initialize_properties_and_components(self, data) {

            if (baseObjectType.nodeId === self.nodeId) {
                return; // nothing to do
            }

            var baseTypeNodeId = self.subtypeOf;
            // istanbul ignore next
            if (!baseTypeNodeId) {
                throw new Error("Object with nodeId " + self.nodeId + " has no Type");
            }

            var baseType = addressSpace.findObject(baseTypeNodeId);
            // istanbul ignore next
            if (!baseType) {
                throw new Error("Cannot find object with nodeId ".red + baseTypeNodeId);
            }

            function _coerceVariant(variantLike) {
                return (variantLike instanceof Variant) ? variantLike : new Variant(variantLike);
            }

            initialize_properties_and_components(baseType, data);

            // get properties and components from base class
            var refProperties = self.getProperties();

            refProperties.forEach(function (ref) {
                var node = addressSpace.findObject(ref.nodeId);
                var lowerName = lowerFirstLetter(node.browseName.name);

                if (options.hasOwnProperty(lowerName)) {
                    data[lowerName] = _coerceVariant(options[lowerName]);
                } else {

                    // add a property , but with a null varoant
                    data[lowerName] =  _coerceVariant({ dataType: DataType.Null});

                    if (node.modellingRule === "Mandatory") {

                        console.log("ERROR : AddressSpace#constructEventData(eventType,options) cannot find property ".red
                            + self.browseName.toString()+ " => "+ lowerName.cyan );
                    } else {

                        console.log("Warning : AddressSpace#constructEventData(eventType,options) cannot find property ".yellow
                            + self.browseName.toString()+ " => "+ lowerName.cyan );
                    }
                    //xx data[lowerName] = node.readValue().value;
                }
                // also store value in index
                data.__nodes[node.nodeId.toString()] = data[lowerName];

            });
        }

        var data = {};
        data.__nodes = {};

        // verify standard properties...

        initialize_properties_and_components(eventTypeNode, data);

        return data;
    };

    /**
     * Verify and complete the event data.
     *
     * @param eventTypeId
     * @param eventData
     */
    AddressSpace.prototype.deprecated_createEventData = function (eventTypeId, eventData) {

        var self = this;

        var eventTypeNode = self.findEventType(eventTypeId);
        /* istanbul ignore next */
        if (!eventTypeNode) {
            throw new Error(" cannot find EvenType for " + eventTypeId);
        }

        if (!eventTypeNode._refImpl) {
            eventTypeNode._refImpl = self.instantiateEvent(eventTypeNode, {});
            eventTypeNode._refData = self.constructEventData(eventTypeNode);
        }
        // reminder : event type cannot be instantiated directly !
        assert(eventTypeNode.isAbstract);

        eventData.eventId = self.generateEventId();

        // phase 1: create simple data structure
        // Has Properties, has components
        var components = eventTypeNode.getComponents();

        //xx console.log(" Components =",components.toString());
        //console.log(" Properties =",eventTypeNode.getProperties());
        console.log(eventTypeNode.toString());

        var eventTypeNodeImpl = eventTypeNode._refImpl;

        // phase 2: verify that existing properties
        Object.keys(eventData).forEach(function (key) {

            console.log(" Kkey =", key, " options =", eventData[key]);

            var uKey = capitalizeFirstLetter(key);

            var varNode = eventTypeNodeImpl.getPropertyByName(uKey);
            assert(varNode !== null);

            assert(varNode instanceof UAVariable);

            var variant = new Variant(eventData[key]);
            //xx console.log("xxxx ",variant);
            //xx console.log("xxxx ",varNode.toString());

            // check that Variant DataType is compatible with the UAVariable dataType
            var nodeDataType = self.findObject(varNode.dataType).browseName;

            /* istanbul ignore next */
            if (!varNode._validate_DataType(variant.dataType)) {
                throw new Error(" Invalid variant dataType");
            }
        });
        // now merge
        eventData = _.defaults(eventData, eventTypeNode._refData);
        //xx console.log("eventNode",eventNode.toString());
        return eventData;

    };

    /**
     * instantiate an event.
     * this will create the unique EventId and will set eventType
     * @method instantiateEvent
     * @param eventTypeId {String|NodeId} the EventType to instantiate
     * @param options {object} a object containing the value to set
     * @param options.eventId {String|NodeId} the EventType Identifier to instantiate (type cannot be abstract)
     * @return node {UADataType}
     */
    AddressSpace.prototype.instantiateEvent = function (eventTypeId, options) {

        var self = this;

        options.eventId = self.generateEventId();

        var eventTypeNode = self.findEventType(eventTypeId);

        /* istanbul ignore next */
        if (!eventTypeNode) {
            throw new Error(" cannot find EvenType for " + eventTypeId);
        }

        // reminder : abstract event type cannot be instantiated directly !
        assert(! eventTypeNode.isAbstract);

        // assert(_.isString(options.browseName));
        options.browseName = options.browseName || "???";

        var eventNode = eventTypeNode.instantiate({
            browseName: options.browseName
            //xx organizedBy: "i=58"
        });

        // set properties
        Object.keys(options).forEach(function (key) {

            // ignore special attributes
            if (key === "browseName") {
                return;
            }
            //xxconsole.log(" Kkey =",key, " options =",options[key]);
            assert(eventNode.hasOwnProperty(key));

            var varNode = eventNode[key];
            assert(varNode instanceof UAVariable);

            var variant = new Variant(options[key]);
            //xx console.log("xxxx ",variant);
            //xx console.log("xxxx ",varNode.toString());

            // check that Variant DataType is compatible with the UAVariable dataType
            var nodeDataType = self.findObject(varNode.dataType).browseName;

            /* istanbul ignore next */
            if (!varNode._validate_DataType(variant.dataType)) {
                throw new Error(" Invalid variant dataType");
            }

            varNode.setValueFromSource(new Variant(options[key]));

        });
        //xx console.log("eventNode",eventNode.toString());
        return eventNode;

    };
};
